import re


YEAR_PATTERN = re.compile(r"\b(19\d{2}|20\d{2})\b")
RANGE_PATTERN = re.compile(
    r"\b(19\d{2}|20\d{2})\b\s*(?:-|\u2013|\u2014|to)\s*\b(19\d{2}|20\d{2})\b",
    flags=re.IGNORECASE,
)


def _merge_ranges(ranges: list[tuple[int, int]]) -> list[tuple[int, int]]:
    if not ranges:
        return []
    ranges.sort(key=lambda x: (x[0], x[1]))
    merged = [ranges[0]]
    for start, end in ranges[1:]:
        last_start, last_end = merged[-1]
        if start <= last_end + 1:
            merged[-1] = (last_start, max(last_end, end))
        else:
            merged.append((start, end))
    return merged


def detect_year_gaps(education_text: str) -> list:
    text = education_text or ""
    ranges: list[tuple[int, int]] = []
    covered_spans: list[tuple[int, int]] = []

    # 1) Explicit ranges like "2023-2027", "2023 to 2027".
    for match in RANGE_PATTERN.finditer(text):
        start_year = int(match.group(1))
        end_year = int(match.group(2))
        low = min(start_year, end_year)
        high = max(start_year, end_year)
        ranges.append((low, high))
        covered_spans.append((match.start(), match.end()))

    # 2) Infer ranges from the same line if it contains multiple years,
    #    e.g. "B.Tech CSE 2023 2027".
    offset = 0
    for line in text.splitlines():
        year_matches = list(YEAR_PATTERN.finditer(line))
        if len(year_matches) >= 2:
            years = [int(m.group(1)) for m in year_matches]
            low, high = min(years), max(years)
            if high - low <= 8:
                ranges.append((low, high))
                for m in year_matches:
                    start = offset + m.start()
                    end = offset + m.end()
                    covered_spans.append((start, end))
        offset += len(line) + 1

    # 3) Standalone years.
    for match in YEAR_PATTERN.finditer(text):
        position = match.start()
        if any(start <= position < end for start, end in covered_spans):
            continue
        year = int(match.group(1))
        ranges.append((year, year))

    merged = _merge_ranges(ranges)
    if len(merged) < 2:
        return []

    gaps = []
    for i in range(len(merged) - 1):
        current_end = merged[i][1]
        next_start = merged[i + 1][0]
        if next_start - current_end > 1:
            gaps.append((current_end, next_start))

    return gaps
